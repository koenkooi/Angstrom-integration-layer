From d457844076501a1f81fa5f867326a2018a61ac98 Mon Sep 17 00:00:00 2001
From: aoliva <aoliva@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Sat, 4 Jun 2011 10:15:48 +0000
Subject: [PATCH] PR debug/47590
 * target.def (delay_sched2, delay_vartrack): New.
 * doc/tm.texi.in: Update.
 * doc/tm.texi: Rebuild.
 * sched-rgn.c (gate_handle_sched2): Fail if delay_sched2.
 * var-tracking.c (gate_handle_var_tracking): Likewise.
 * config/bfin/bfin.c (bfin_flag_schedule_insns2): Drop.
 (bfin_flag_var_tracking): Drop.
 (output_file_start): Don't save and override flag_var_tracking.
 (bfin_option_override): Ditto flag_schedule_insns_after_reload.
 (bfin_reorg): Test original variables.
 (TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.
 * config/ia64/ia64.c (ia64_flag_schedule_insns2): Drop.
 (ia64_flag_var_tracking): Drop.
 (TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.
 (ia64_file_start): Don't save and override flag_var_tracking.
 (ia64_override_options_after_change): Ditto
 flag_schedule_insns_after_reload.
 (ia64_reorg): Test original variables.
 * config/picochip/picochip.c (picochip_flag_schedule_insns2): Drop.
 (picochip_flag_var_tracking): Drop.
 (TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.
 (picochip_option_override): Don't save and override
 flag_schedule_insns_after_reload.
 (picochip_asm_file_start): Ditto flag_var_tracking.
 (picochip_reorg): Test original variables.
 * config/spu/spu.c (spu_flag_var_tracking): Drop.
 (TARGET_DELAY_VARTRACK): Define.
 (spu_var_tracking): New.
 (spu_machine_dependent_reorg): Call it.
 (asm_file_start): Don't save and override flag_var_tracking.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_6-branch@174637 138bc75d-0d04-0410-961f-82ee72b054a4

index a6f2a38..60cd09e 100644
--- a/gcc/config/bfin/bfin.c
+++ b/gcc/config/bfin/bfin.c
@@ -88,14 +88,6 @@ static int ret_regs[] = FUNCTION_RETURN_REGISTERS;
 /* Nonzero if -mshared-library-id was given.  */
 static int bfin_lib_id_given;
 
-/* Nonzero if -fschedule-insns2 was given.  We override it and
-   call the scheduler ourselves during reorg.  */
-static int bfin_flag_schedule_insns2;
-
-/* Determines whether we run variable tracking in machine dependent
-   reorganization.  */
-static int bfin_flag_var_tracking;
-
 /* -mcpu support */
 bfin_cpu_t bfin_cpu_type = BFIN_CPU_UNKNOWN;
 
@@ -356,13 +348,6 @@ output_file_start (void)
   FILE *file = asm_out_file;
   int i;
 
-  /* Variable tracking should be run after all optimizations which change order
-     of insns.  It also needs a valid CFG.  This can't be done in
-     bfin_option_override, because flag_var_tracking is finalized after
-     that.  */
-  bfin_flag_var_tracking = flag_var_tracking;
-  flag_var_tracking = 0;
-
   fprintf (file, ".file \"%s\";\n", input_filename);
   
   for (i = 0; arg_regs[i] >= 0; i++)
@@ -2725,11 +2710,6 @@ bfin_option_override (void)
 
   flag_schedule_insns = 0;
 
-  /* Passes after sched2 can break the helpful TImode annotations that
-     haifa-sched puts on every insn.  Just do scheduling in reorg.  */
-  bfin_flag_schedule_insns2 = flag_schedule_insns_after_reload;
-  flag_schedule_insns_after_reload = 0;
-
   init_machine_status = bfin_init_machine_status;
 }
 
@@ -5502,7 +5482,7 @@ bfin_reorg (void)
      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */
   compute_bb_for_insn ();
 
-  if (bfin_flag_schedule_insns2)
+  if (flag_schedule_insns_after_reload)
     {
       splitting_for_sched = 1;
       split_all_insns ();
@@ -5531,7 +5511,7 @@ bfin_reorg (void)
 
   workaround_speculation ();
 
-  if (bfin_flag_var_tracking)
+  if (flag_var_tracking)
     {
       timevar_push (TV_VAR_TRACKING);
       variable_tracking_main ();
@@ -6702,4 +6682,14 @@ bfin_conditional_register_usage (void)
 #undef TARGET_TRAMPOLINE_INIT
 #define TARGET_TRAMPOLINE_INIT bfin_trampoline_init
 
+/* Passes after sched2 can break the helpful TImode annotations that
+   haifa-sched puts on every insn.  Just do scheduling in reorg.  */
+#undef TARGET_DELAY_SCHED2
+#define TARGET_DELAY_SCHED2 true
+
+/* Variable tracking should be run after all optimizations which
+   change order of insns.  It also needs a valid CFG.  */
+#undef TARGET_DELAY_VARTRACK
+#define TARGET_DELAY_VARTRACK true
+
 struct gcc_target targetm = TARGET_INITIALIZER;
diff --git a/gcc/config/ia64/ia64.c b/gcc/config/ia64/ia64.c
index 1d3f8b1..71de697 100644
--- a/gcc/config/ia64/ia64.c
+++ b/gcc/config/ia64/ia64.c
@@ -105,14 +105,6 @@ static const char * const ia64_output_reg_names[8] =
 /* Which cpu are we scheduling for.  */
 enum processor_type ia64_tune = PROCESSOR_ITANIUM2;
 
-/* Determines whether we run our final scheduling pass or not.  We always
-   avoid the normal second scheduling pass.  */
-static int ia64_flag_schedule_insns2;
-
-/* Determines whether we run variable tracking in machine dependent
-   reorganization.  */
-static int ia64_flag_var_tracking;
-
 /* Variables which are this size or smaller are put in the sdata/sbss
    sections.  */
 
@@ -634,6 +626,14 @@ static const struct default_options ia64_option_optimization_table[] =
 #undef TARGET_PREFERRED_RELOAD_CLASS
 #define TARGET_PREFERRED_RELOAD_CLASS ia64_preferred_reload_class
 
+#undef TARGET_DELAY_SCHED2
+#define TARGET_DELAY_SCHED2 true
+
+/* Variable tracking should be run after all optimizations which
+   change order of insns.  It also needs a valid CFG.  */
+#undef TARGET_DELAY_VARTRACK
+#define TARGET_DELAY_VARTRACK true
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 typedef enum
@@ -2389,13 +2389,6 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,
 static void
 ia64_file_start (void)
 {
-  /* Variable tracking should be run after all optimizations which change order
-     of insns.  It also needs a valid CFG.  This can't be done in
-     ia64_option_override, because flag_var_tracking is finalized after
-     that.  */
-  ia64_flag_var_tracking = flag_var_tracking;
-  flag_var_tracking = 0;
-
   default_file_start ();
   emit_safe_across_calls ();
 }
@@ -5733,9 +5726,6 @@ ia64_option_override (void)
 static void
 ia64_override_options_after_change (void)
 {
-  ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;
-  flag_schedule_insns_after_reload = 0;
-
   if (optimize >= 3
       && !global_options_set.x_flag_selective_scheduling
       && !global_options_set.x_flag_selective_scheduling2)
@@ -9407,7 +9397,7 @@ ia64_reorg (void)
   if (optimize == 0)
     split_all_insns ();
 
-  if (optimize && ia64_flag_schedule_insns2
+  if (optimize && flag_schedule_insns_after_reload
       && dbg_cnt (ia64_sched2))
     {
       timevar_push (TV_SCHED2);
@@ -9537,7 +9527,7 @@ ia64_reorg (void)
 
   emit_predicate_relation_info ();
 
-  if (ia64_flag_var_tracking)
+  if (flag_var_tracking)
     {
       timevar_push (TV_VAR_TRACKING);
       variable_tracking_main ();
diff --git a/gcc/config/picochip/picochip.c b/gcc/config/picochip/picochip.c
index 1ca95b4..dd4e34e 100644
--- a/gcc/config/picochip/picochip.c
+++ b/gcc/config/picochip/picochip.c
@@ -149,13 +149,6 @@ const char *picochip_regnames[] = REGISTER_NAMES;
 
 /* Target scheduling information. */
 
-/* Determine whether we run our final scheduling pass or not.  We always
-   avoid the normal second scheduling pass.  */
-int picochip_flag_schedule_insns2;
-
-/* Check if variable tracking needs to be run. */
-int picochip_flag_var_tracking;
-
 /* This flag indicates whether the next instruction to be output is a
    VLIW continuation instruction.  It is used to communicate between
    final_prescan_insn and asm_output_opcode. */
@@ -343,6 +336,17 @@ static const struct default_options picochip_option_optimization_table[] =
 #undef TARGET_EXCEPT_UNWIND_INFO
 #define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info
 
+/* The 2nd scheduling pass option is switched off, and a machine
+   dependent reorganisation ensures that it is run later on, after the
+   second jump optimisation.  */
+#undef TARGET_DELAY_SCHED2
+#define TARGET_DELAY_SCHED2 true
+
+/* Variable tracking should be run after all optimizations which
+   change order of insns.  It also needs a valid CFG.  */
+#undef TARGET_DELAY_VARTRACK
+#define TARGET_DELAY_VARTRACK true
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 
@@ -356,10 +360,7 @@ picochip_return_in_memory(const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
   return ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 4);
 }
 
-/* Allow some options to be overriden.  In particular, the 2nd
-   scheduling pass option is switched off, and a machine dependent
-   reorganisation ensures that it is run later on, after the second
-   jump optimisation. */
+/* Allow some options to be overriden. */
 
 static void
 picochip_option_override (void)
@@ -396,18 +397,16 @@ picochip_option_override (void)
   if (optimize >= 1)
     flag_section_anchors = 1;
 
-  /* Turn off the second scheduling pass, and move it to
-     picochip_reorg, to avoid having the second jump optimisation
-     trash the instruction modes (e.g., instructions are changed to
-     TImode to mark the beginning of cycles). Two types of DFA
-     scheduling are possible: space and speed. In both cases,
-     instructions are reordered to avoid stalls (e.g., memory loads
-     stall for one cycle). Speed scheduling will also enable VLIW
-     instruction packing. VLIW instructions use more code space, so
-     VLIW scheduling is disabled when scheduling for size. */
-  picochip_flag_schedule_insns2 = flag_schedule_insns_after_reload;
-  flag_schedule_insns_after_reload = 0;
-  if (picochip_flag_schedule_insns2)
+  /* The second scheduling pass runs within picochip_reorg, to avoid
+     having the second jump optimisation trash the instruction modes
+     (e.g., instructions are changed to TImode to mark the beginning
+     of cycles).  Two types of DFA scheduling are possible: space and
+     speed.  In both cases, instructions are reordered to avoid stalls
+     (e.g., memory loads stall for one cycle).  Speed scheduling will
+     also enable VLIW instruction packing.  VLIW instructions use more
+     code space, so VLIW scheduling is disabled when scheduling for
+     size.  */
+  if (flag_schedule_insns_after_reload)
     {
       if (optimize_size)
 	picochip_schedule_type = DFA_TYPE_SPACE;
@@ -461,7 +460,6 @@ picochip_option_override (void)
 	error ("invalid mul type specified (%s) - expected mac, mul or none",
 	       picochip_mul_type_string);
     }
-
 }
 
 
@@ -1813,13 +1811,6 @@ picochip_asm_file_start (void)
     fprintf (asm_out_file, "// Has multiply: Yes (Mac unit)\n");
   else
     fprintf (asm_out_file, "// Has multiply: No\n");
-
-  /* Variable tracking should be run after all optimizations which change order
-     of insns.  It also needs a valid CFG.  This can't be done in
-     picochip_option_override, because flag_var_tracking is finalized after
-     that.  */
-  picochip_flag_var_tracking = flag_var_tracking;
-  flag_var_tracking = 0;
 }
 
 /* Output the end of an ASM file. */
@@ -3369,15 +3360,16 @@ picochip_reorg (void)
 	  delete_insn (prologue_end_note);
 	}
     }
-  if (picochip_flag_var_tracking)
-  {
-    timevar_push (TV_VAR_TRACKING);
-    variable_tracking_main ();
-    /* We also have to deal with variable tracking notes in the middle 
-       of VLIW packets. */
-    reorder_var_tracking_notes();
-    timevar_pop (TV_VAR_TRACKING);
-  }
+
+  if (flag_var_tracking)
+    {
+      timevar_push (TV_VAR_TRACKING);
+      variable_tracking_main ();
+      /* We also have to deal with variable tracking notes in the
+	 middle of VLIW packets. */
+      reorder_var_tracking_notes();
+      timevar_pop (TV_VAR_TRACKING);
+    }
 }
 
 /* Return the ALU character identifier for the current
diff --git a/gcc/config/spu/spu.c b/gcc/config/spu/spu.c
index d80d86d..5c30a6e 100644
--- a/gcc/config/spu/spu.c
+++ b/gcc/config/spu/spu.c
@@ -245,10 +245,6 @@ int spu_tune;
    inserted in pairs, so we round down. */
 int spu_hint_dist = (8*4) - (2*4);
 
-/* Determines whether we run variable tracking in machine dependent
-   reorganization.  */
-static int spu_flag_var_tracking;
-
 enum spu_immediate {
   SPU_NONE,
   SPU_IL,
@@ -495,6 +491,11 @@ static const struct attribute_spec spu_attribute_table[] =
 #undef TARGET_REF_MAY_ALIAS_ERRNO
 #define TARGET_REF_MAY_ALIAS_ERRNO spu_ref_may_alias_errno
 
+/* Variable tracking should be run after all optimizations which
+   change order of insns.  It also needs a valid CFG.  */
+#undef TARGET_DELAY_VARTRACK
+#define TARGET_DELAY_VARTRACK true
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 static void
@@ -2686,6 +2687,19 @@ insert_hbrp (void)
 
 static int in_spu_reorg;
 
+static void
+spu_var_tracking (void)
+{
+  if (flag_var_tracking)
+    {
+      df_analyze ();
+      timevar_push (TV_VAR_TRACKING);
+      variable_tracking_main ();
+      timevar_pop (TV_VAR_TRACKING);
+      df_finish_pass (false);
+    }
+}
+
 /* Insert branch hints.  There are no branch optimizations after this
    pass, so it's safe to set our branch hints now. */
 static void
@@ -2705,6 +2719,7 @@ spu_machine_dependent_reorg (void)
          function might have hinted a call or return. */
       insert_hbrp ();
       pad_bb ();
+      spu_var_tracking ();
       return;
     }
 
@@ -2911,14 +2926,7 @@ spu_machine_dependent_reorg (void)
 	  XVECEXP (unspec, 0, 0) = plus_constant (label_ref, offset);
       }
 
-  if (spu_flag_var_tracking)
-    {
-      df_analyze ();
-      timevar_push (TV_VAR_TRACKING);
-      variable_tracking_main ();
-      timevar_pop (TV_VAR_TRACKING);
-      df_finish_pass (false);
-    }
+  spu_var_tracking ();
 
   free_bb_for_insn ();
 
@@ -7049,19 +7057,6 @@ spu_libgcc_shift_count_mode (void)
 static void
 asm_file_start (void)
 {
-  /* Variable tracking should be run after all optimizations which
-     change order of insns.  It also needs a valid CFG.  Therefore,
-     *if* we make nontrivial changes in machine-dependent reorg,
-     run variable tracking after those.  However, if we do not run
-     our machine-dependent reorg pass, we must still run the normal
-     variable tracking pass (or else we will ICE in final since
-     debug insns have not been removed).  */
-  if (TARGET_BRANCH_HINTS && optimize)
-    {
-      spu_flag_var_tracking = flag_var_tracking;
-      flag_var_tracking = 0;
-    }
-
   default_file_start ();
 }
 
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index 85e1d88..f7c0cce 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -9430,6 +9430,14 @@ tables, and hence is desirable if it works.
 True if the @code{.debug_pubtypes} and @code{.debug_pubnames} sections should be emitted.  These sections are not used on most platforms, and in particular GDB does not use them.
 @end deftypevr
 
+@deftypevr {Target Hook} bool TARGET_DELAY_SCHED2
+True if sched2 is not to be run at its normal place.  This usually means it will be run as part of machine-specific reorg.
+@end deftypevr
+
+@deftypevr {Target Hook} bool TARGET_DELAY_VARTRACK
+True if vartrack is not to be run at its normal place.  This usually means it will be run as part of machine-specific reorg.
+@end deftypevr
+
 @defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
 A C statement to issue assembly directives that create a difference
 @var{lab1} minus @var{lab2}, using an integer of the given @var{size}.
diff --git a/gcc/doc/tm.texi.in b/gcc/doc/tm.texi.in
index a799bc4..40acf65 100644
--- a/gcc/doc/tm.texi.in
+++ b/gcc/doc/tm.texi.in
@@ -9388,6 +9388,10 @@ tables, and hence is desirable if it works.
 
 @hook TARGET_WANT_DEBUG_PUB_SECTIONS
 
+@hook TARGET_DELAY_SCHED2
+
+@hook TARGET_DELAY_VARTRACK
+
 @defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})
 A C statement to issue assembly directives that create a difference
 @var{lab1} minus @var{lab2}, using an integer of the given @var{size}.
diff --git a/gcc/sched-rgn.c b/gcc/sched-rgn.c
index 6c4fd46..e6400b6 100644
--- a/gcc/sched-rgn.c
+++ b/gcc/sched-rgn.c
@@ -3518,7 +3518,7 @@ gate_handle_sched2 (void)
 {
 #ifdef INSN_SCHEDULING
   return optimize > 0 && flag_schedule_insns_after_reload
-    && dbg_cnt (sched2_func);
+    && !targetm.delay_sched2 && dbg_cnt (sched2_func);
 #else
   return 0;
 #endif
diff --git a/gcc/target.def b/gcc/target.def
index 57134cb..ecacd44 100644
--- a/gcc/target.def
+++ b/gcc/target.def
@@ -2723,6 +2723,16 @@ DEFHOOKPOD
  in particular GDB does not use them.",
  bool, false)
 
+DEFHOOKPOD
+(delay_sched2, "True if sched2 is not to be run at its normal place.  \
+This usually means it will be run as part of machine-specific reorg.",
+bool, false)
+
+DEFHOOKPOD
+(delay_vartrack, "True if vartrack is not to be run at its normal place.  \
+This usually means it will be run as part of machine-specific reorg.",
+bool, false)
+
 /* Leave the boolean fields at the end.  */
 
 /* Empty macro arguments are undefined in C90, so use an empty macro.  */
diff --git a/gcc/var-tracking.c b/gcc/var-tracking.c
index b7ba0b9..ab141c1 100644
--- a/gcc/var-tracking.c
+++ b/gcc/var-tracking.c
@@ -8615,7 +8615,7 @@ variable_tracking_main (void)
 static bool
 gate_handle_var_tracking (void)
 {
-  return (flag_var_tracking);
+  return (flag_var_tracking && !targetm.delay_vartrack);
 }
 
 
-- 
1.7.0.4

