From aa15fbe864f58be935154f76f8ebf144988e7746 Mon Sep 17 00:00:00 2001
From: jakub <jakub@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Wed, 25 May 2011 07:03:25 +0000
Subject: [PATCH] 	PR c++/49136
 	* semantics.c (cxx_eval_bit_field_ref): Handle the
 	case when BIT_FIELD_REF doesn't cover only a single field.

	* g++.dg/cpp0x/constexpr-bitfield2.C: New test.
	* g++.dg/cpp0x/constexpr-bitfield3.C: New test.


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_6-branch@174169 138bc75d-0d04-0410-961f-82ee72b054a4

index bd33bac..6207b12 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -6391,6 +6391,9 @@ cxx_eval_bit_field_ref (const constexpr_call *call, tree t,
 			bool *non_constant_p)
 {
   tree orig_whole = TREE_OPERAND (t, 0);
+  tree retval, fldval, utype, mask;
+  bool fld_seen = false;
+  HOST_WIDE_INT istart, isize;
   tree whole = cxx_eval_constant_expression (call, orig_whole,
 					     allow_non_constant, addr,
 					     non_constant_p);
@@ -6411,12 +6414,47 @@ cxx_eval_bit_field_ref (const constexpr_call *call, tree t,
     return t;
 
   start = TREE_OPERAND (t, 2);
+  istart = tree_low_cst (start, 0);
+  isize = tree_low_cst (TREE_OPERAND (t, 1), 0);
+  utype = TREE_TYPE (t);
+  if (!TYPE_UNSIGNED (utype))
+    utype = build_nonstandard_integer_type (TYPE_PRECISION (utype), 1);
+  retval = build_int_cst (utype, 0);
   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)
     {
-      if (bit_position (field) == start)
+      tree bitpos = bit_position (field);
+      if (bitpos == start && DECL_SIZE (field) == TREE_OPERAND (t, 1))
 	return value;
+      if (TREE_CODE (TREE_TYPE (field)) == INTEGER_TYPE
+	  && TREE_CODE (value) == INTEGER_CST
+	  && host_integerp (bitpos, 0)
+	  && host_integerp (DECL_SIZE (field), 0))
+	{
+	  HOST_WIDE_INT bit = tree_low_cst (bitpos, 0);
+	  HOST_WIDE_INT sz = tree_low_cst (DECL_SIZE (field), 0);
+	  HOST_WIDE_INT shift;
+	  if (bit >= istart && bit + sz <= istart + isize)
+	    {
+	      fldval = fold_convert (utype, value);
+	      mask = build_int_cst_type (utype, -1);
+	      mask = fold_build2 (LSHIFT_EXPR, utype, mask,
+				  size_int (TYPE_PRECISION (utype) - sz));
+	      mask = fold_build2 (RSHIFT_EXPR, utype, mask,
+				  size_int (TYPE_PRECISION (utype) - sz));
+	      fldval = fold_build2 (BIT_AND_EXPR, utype, fldval, mask);
+	      shift = bit - istart;
+	      if (BYTES_BIG_ENDIAN)
+		shift = TYPE_PRECISION (utype) - shift - sz;
+	      fldval = fold_build2 (LSHIFT_EXPR, utype, fldval,
+				    size_int (shift));
+	      retval = fold_build2 (BIT_IOR_EXPR, utype, retval, fldval);
+	      fld_seen = true;
+	    }
+	}
     }
-  gcc_unreachable();
+  if (fld_seen)
+    return fold_convert (TREE_TYPE (t), retval);
+  gcc_unreachable ();
   return error_mark_node;
 }
 
new file mode 100644
index 0000000..531bf31
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-bitfield2.C
@@ -0,0 +1,19 @@
+// PR c++/49136
+// { dg-do compile }
+// { dg-options "-std=c++0x" }
+
+struct day
+{
+  unsigned d : 5;
+  unsigned n : 3;
+  constexpr explicit day (int dd) : d(dd), n(7) {}
+};
+
+struct date {
+  int d;
+  constexpr date (day dd) : d(dd.n != 7 ? 7 : dd.d) {}
+};
+
+constexpr day d(0);
+constexpr date dt(d);
+static_assert (dt.d == 0, "Error");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-bitfield3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-bitfield3.C
new file mode 100644
index 0000000..b0ecbfb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-bitfield3.C
@@ -0,0 +1,33 @@
+// PR c++/49136
+// { dg-do compile }
+// { dg-options "-std=c++0x" }
+
+struct S
+{
+  unsigned : 1; unsigned s : 27; unsigned : 4;
+  constexpr S (unsigned int x) : s(x) {}
+};
+
+template <typename S>
+struct T
+{
+  unsigned int t;
+  constexpr T (S s) : t(s.s != 7 ? 0 : s.s) {}
+  constexpr T (S s, S s2) : t(s.s != s2.s ? 0 : s.s) {}
+};
+
+constexpr S s (7), s2 (7);
+constexpr T<S> t (s), t2 (s, s2);
+static_assert (t.t == 7, "Error");
+static_assert (t2.t == 7, "Error");
+
+struct U
+{
+  int a : 1; int s : 1;
+  constexpr U (int x, int y) : a (x), s (y) {}
+};
+
+constexpr U u (0, -1), u2 (-1, -1);
+constexpr T<U> t3 (u), t4 (u, u2);
+static_assert (t3.t == 0, "Error");
+static_assert (t4.t == -1, "Error");
-- 
1.7.0.4

