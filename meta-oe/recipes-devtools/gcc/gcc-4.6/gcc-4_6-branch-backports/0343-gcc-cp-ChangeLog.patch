From 2cf0a578b9883daa7f515380736d29b537a21ef7 Mon Sep 17 00:00:00 2001
From: fabien <fabien@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Wed, 25 May 2011 20:52:15 +0000
Subject: [PATCH] gcc/cp/ChangeLog:

2011-05-25  Fabien Chene  <fabien@gcc.gnu.org>
	* init.c (diagnose_uninitialized_cst_or_ref_member_1): Use
	permerror instead of error, adjust the error count.

gcc/testsuite/ChangeLog:

2011-05-25  Fabien Chene  <fabien@gcc.gnu.org>
	* g++.dg/init/pr25811-2.C: New.
	* g++.dg/init/pr25811-3.C: New.
	* g++.dg/init/pr25811-4.C: New.


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_6-branch@174239 138bc75d-0d04-0410-961f-82ee72b054a4

index 172a71a..ef9e20e 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -1893,6 +1893,7 @@ diagnose_uninitialized_cst_or_ref_member_1 (tree type, tree origin,
 {
   tree field;
   int error_count = 0;
+  bool permissive = global_dc->permissive;
 
   if (type_has_user_provided_constructor (type))
     return 0;
@@ -1911,32 +1912,45 @@ diagnose_uninitialized_cst_or_ref_member_1 (tree type, tree origin,
 
       if (TREE_CODE (field_type) == REFERENCE_TYPE)
 	{
-	  ++ error_count;
 	  if (complain)
 	    {
+	      if (!permissive || !using_new)
+		++ error_count;
+
 	      if (using_new)
-		error ("uninitialized reference member in %q#T "
-		       "using %<new%> without new-initializer", origin);
+		  permerror (input_location,
+			     "uninitialized reference member in %q#T "
+			     "using %<new%> without new-initializer", origin);
 	      else
-		error ("uninitialized reference member in %q#T", origin);
+		  error ("uninitialized reference member in %q#T", origin);
+
 	      inform (DECL_SOURCE_LOCATION (field),
 		      "%qD should be initialized", field);
 	    }
+	  else
+	    ++ error_count;
 	}
 
       if (CP_TYPE_CONST_P (field_type))
 	{
-	  ++ error_count;
 	  if (complain)
 	    {
+	      if (!permissive)
+		++ error_count;
+
 	      if (using_new)
-		error ("uninitialized const member in %q#T "
-		       "using %<new%> without new-initializer", origin);
-	      else
-		error ("uninitialized const member in %q#T", origin);
+		permerror (input_location,
+			   "uninitialized const member in %q#T "
+			   "using %<new%> without new-initializer", origin);
+	      else 
+		permerror (input_location,
+			   "uninitialized const member in %q#T", origin);
+
 	      inform (DECL_SOURCE_LOCATION (field),
 		      "%qD should be initialized", field);
 	    }
+	  else
+	    ++ error_count;
 	}
 
       if (CLASS_TYPE_P (field_type))
new file mode 100644
index 0000000..3a36dd4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr25811-2.C
@@ -0,0 +1,26 @@
+// { dg-do compile }
+// { dg-options -fpermissive }
+
+struct A
+{
+  int const i; // { dg-message "should be initialized" }
+};
+
+struct B
+{
+  int& r; // { dg-message "should be initialized" }
+};
+
+struct C
+{
+  int const i : 1; // { dg-message "should be initialized" }
+};
+
+void f()
+{
+  new A;  // { dg-warning "uninitialized" }
+  new B;  // { dg-warning "uninitialized" }
+  new C;  // { dg-warning "uninitialized" }
+  C c;    // { dg-warning "uninitialized" }
+  A a[1]; // { dg-warning "uninitialized" }
+}
diff --git a/gcc/testsuite/g++.dg/init/pr25811-3.C b/gcc/testsuite/g++.dg/init/pr25811-3.C
new file mode 100644
index 0000000..631da5b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr25811-3.C
@@ -0,0 +1,38 @@
+// { dg-do compile }
+
+struct A { int const i; };
+struct B { int& i; };
+struct C { int i; };
+
+template< class T >
+class is_constructible_via_new_without_initializer
+{
+    template<int> class size {};
+
+    typedef char yes_type;
+    struct no_type { char data[2]; };
+
+    template <class U>
+    static yes_type sfinae (size< sizeof (new U) >*);
+
+    template <class U>
+    static no_type sfinae (...);
+
+public:
+  static const bool value = sizeof (sfinae<T>(0)) == sizeof (yes_type);
+};
+
+#define JOIN( X, Y ) DO_JOIN( X, Y )
+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)
+#define DO_JOIN2( X, Y ) X##Y
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)
+#else
+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]
+#endif
+
+STATIC_ASSERT (!is_constructible_via_new_without_initializer<A>::value);
+STATIC_ASSERT (!is_constructible_via_new_without_initializer<B>::value);
+STATIC_ASSERT (is_constructible_via_new_without_initializer<C>::value);
+
diff --git a/gcc/testsuite/g++.dg/init/pr25811-4.C b/gcc/testsuite/g++.dg/init/pr25811-4.C
new file mode 100644
index 0000000..abfb3d9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr25811-4.C
@@ -0,0 +1,38 @@
+// { dg-do compile }
+// { dg-options "-fpermissive" }
+
+struct A { int const i; };
+struct B { int& i; };
+struct C { int i; };
+
+template< class T >
+class is_constructible_via_new_without_initializer
+{
+    template<int> class size {};
+
+    typedef char yes_type;
+    struct no_type { char data[2]; };
+
+    template <class U>
+    static yes_type sfinae (size< sizeof (new U) >*);
+
+    template <class U>
+    static no_type sfinae (...);
+
+public:
+  static const bool value = sizeof (sfinae<T>(0)) == sizeof (yes_type);
+};
+
+#define JOIN( X, Y ) DO_JOIN( X, Y )
+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)
+#define DO_JOIN2( X, Y ) X##Y
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)
+#else
+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]
+#endif
+
+STATIC_ASSERT (!is_constructible_via_new_without_initializer<A>::value);
+STATIC_ASSERT (!is_constructible_via_new_without_initializer<B>::value);
+STATIC_ASSERT (is_constructible_via_new_without_initializer<C>::value);
-- 
1.7.0.4

