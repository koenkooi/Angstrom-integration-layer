#!/bin/bash
AUTO=0
AUTO_CL=0

# Prevent environment leakage to these vars.
unset TO
unset CC
unset AUTO_CC

usage()
{
cat <<EOM
Usage: $(basename $0) [-h] [-a] [-c] [[-t email]...] -p pull-dir 
  -a           Send the cover letter to every recipient listed in Cc and
               Signed-off-by lines found in the cover letter and the patches.
	       This option implies -c.
  -c           Expand the Cc list for the individual patches using the Cc and
               Signed-off-by lines from the same patch.
  -p pull-dir  Directory containing summary and patch files
  -t email     Explicitly add email to the recipients
EOM
}

# Collect addresses from a patch into AUTO_CC
# $1: a patch file
harvest_recipients()
{
	PATCH=$1
	export IFS=$',\n'
	for REGX in "^[Cc][Cc]: *" "^[Ss]igned-[Oo]ff-[Bb]y: *"; do
		for EMAIL in $(sed '/^---$/q' $PATCH | grep -e "$REGX" | sed "s/$REGX//"); do
			if [ "${AUTO_CC/$EMAIL/}" == "$AUTO_CC" ] && [ -n "$EMAIL" ]; then
				if [ -z "$AUTO_CC" ]; then
					AUTO_CC=$EMAIL;
				else
					AUTO_CC="$AUTO_CC,$EMAIL";
				fi
			fi
		done
	done
	unset IFS
}

check_git_sendemail_config()
{
	GIT_SMTP=$(git config sendemail.smtpserver)
	GIT_FROM=$(git config sendemail.from)
	if [ -z "$GIT_SMTP" ] || [ -z "$GIT_FROM" ]; then
		echo "ERROR: git sendemail is not configured."
		echo "Please read GIT-SEND-EMAIL(1) and configure:"
		echo "  sendemail.smtpserver"
		echo "  sendemail.from"
		exit 1
	fi
}

# Parse and verify arguments
while getopts "achp:t:" OPT; do
	case $OPT in
	a)
		AUTO_CL=1
		AUTO=1
		;;
	c)
		AUTO=1
		;;
	h)
		usage
		exit 0
		;;
	p)
		PDIR=${OPTARG%/}
		if [ ! -d $PDIR ]; then
			echo "ERROR: pull-dir \"$PDIR\" does not exist."
			usage
			exit 1
		fi
		;;
	t)
		if [ -n "$TO" ]; then
			TO="$TO,$OPTARG"
		else
			TO="$OPTARG"
		fi
		;;
	esac
done

# Abort early if git-send-email is not properly configured
check_git_sendemail_config

if [ -z "$PDIR" ]; then
	echo "ERROR: you must specify a pull-dir."
	usage
	exit 1
fi


# Verify the cover letter is complete and free of tokens
CL="$PDIR/0000-cover-letter.patch"
for TOKEN in SUBJECT BLURB; do
	grep -q "*** $TOKEN HERE ***" "$CL"
	if [ $? -eq 0 ]; then
		echo "ERROR: Please edit $CL and try again (Look for '*** $TOKEN HERE ***')."
		exit 1
	fi
done


# Harvest emails from the generated patches and populate AUTO_CC.
if [ $AUTO_CL -eq 1 ]; then
	for PATCH in $PDIR/*.patch; do
		harvest_recipients $PATCH
	done
fi

AUTO_TO="$(git config sendemail.to)"
if [ -n "$AUTO_TO" ]; then
	if [ -n "$TO" ]; then
		TO="$TO,$AUTO_TO"
	else
		TO="$AUTO_TO"
	fi
fi

if [ -z "$TO" ] && [ -z "$AUTO_CC" ]; then
	echo "ERROR: you have not specified any recipients."
	usage
	exit 1
fi


# Generate report for the user and require confirmation before sending
cat <<EOM
The following patches:
$(for PATCH in $PDIR/*.patch; do echo "    $PATCH"; done)

will now be sent via the git send-email command. Git will prompt you before
sending any email.

EOM
echo "Continue? [y/N] "
read cont

if [ "$cont" == "y" ] || [ "$cont" == "Y" ]; then
	ERROR=0
	export IFS=$','
	GIT_TO=$(for R in $TO; do echo -n "--to='$R' "; done)
	GIT_CC=$(for R in $AUTO_CC; do echo -n "--cc='$R' "; done)
	unset IFS
	for PATCH in $PDIR/*patch; do
		if [ $AUTO -eq 1 ]; then
			if [ $PATCH == "$CL" ] && [ $AUTO_CL -eq 1 ]; then
				# Send the cover letter to every recipient, both
				# specified as well as harvested.
				eval "git send-email $GIT_TO $GIT_CC --confirm=always --no-chain-reply-to --suppress-cc=all $PATCH"
			else
				# Send the patch to the specified recipients and
				# those git finds in this specific patch.
				eval "git send-email $GIT_TO --confirm=always --no-chain-reply-to --signed-off-by-cc $PATCH"
			fi
		else
			# Only send to the explicitly specified recipients
			eval "git send-email $GIT_TO --confirm=always --no-chain-reply-to --suppress-cc=all $PATCH"
		fi
		if [ $? -eq 1 ]; then
			ERROR=1
		fi
	done

	if [ $ERROR -eq 1 ]; then
		echo "ERROR: Failed to send one or more messages."
	fi
else
	echo "Send aborted."
fi

